#!/usr/bin/env python3
"""
ccb (Claude Code Bridge) - Unified AI Launcher
Supports Claude + Codex / Claude + Gemini / all three simultaneously
Supports tmux, WezTerm and iTerm2 terminals
"""

import sys
import os
import json
import time
import subprocess
import signal
import atexit
import argparse
import uuid
import getpass
import platform
import tempfile
import re
import shutil
import posixpath
import shlex
from pathlib import Path

script_dir = Path(__file__).resolve().parent
sys.path.insert(0, str(script_dir / "lib"))
from terminal import TmuxBackend, WeztermBackend, Iterm2Backend, detect_terminal, is_wsl, get_shell_type
from compat import setup_windows_encoding
from ccb_config import get_backend_env
from session_utils import safe_write_session, check_session_writable
from pane_registry import upsert_registry
from i18n import t

setup_windows_encoding()

backend_env = get_backend_env()
if backend_env and not os.environ.get("CCB_BACKEND_ENV"):
    os.environ["CCB_BACKEND_ENV"] = backend_env

VERSION = "4.0.0"
GIT_COMMIT = ""
GIT_DATE = ""

_WIN_DRIVE_RE = re.compile(r"^[A-Za-z]:([/\\\\]|$)")
_MNT_DRIVE_RE = re.compile(r"^/mnt/([A-Za-z])/(.*)$")
_MSYS_DRIVE_RE = re.compile(r"^/([A-Za-z])/(.*)$")


def _looks_like_windows_path(value: str) -> bool:
    s = value.strip()
    if not s:
        return False
    if _WIN_DRIVE_RE.match(s):
        return True
    if s.startswith("\\\\") or s.startswith("//"):
        return True
    return False


def _normalize_path_for_match(value: str) -> str:
    """
    Normalize a path-like string for loose matching across Windows/WSL/MSYS variations.
    This is used only for selecting a session for *current* cwd, so favor robustness.
    """
    s = (value or "").strip()
    if not s:
        return ""

    # Expand "~" early (common in shell-originated values). If expansion fails, keep original.
    if s.startswith("~"):
        try:
            s = os.path.expanduser(s)
        except Exception:
            pass

    # If the path is relative, absolutize it against current cwd for matching purposes only.
    # This reduces false negatives when upstream tools record a relative cwd.
    # NOTE: treat Windows-like absolute paths as absolute even on non-Windows hosts.
    try:
        preview = s.replace("\\", "/")
        is_abs = (
            preview.startswith("/")
            or preview.startswith("//")
            or bool(_WIN_DRIVE_RE.match(preview))
            or preview.startswith("\\\\")
        )
        if not is_abs:
            s = str((Path.cwd() / Path(s)).absolute())
    except Exception:
        pass

    s = s.replace("\\", "/")

    # Map WSL drive mount to Windows-style drive path for comparison.
    m = _MNT_DRIVE_RE.match(s)
    if m:
        drive = m.group(1).lower()
        rest = m.group(2)
        s = f"{drive}:/{rest}"
    else:
        # Map MSYS /c/... to c:/... (Git-Bash/MSYS2 environments on Windows).
        m = _MSYS_DRIVE_RE.match(s)
        if m and ("MSYSTEM" in os.environ or os.name == "nt"):
            drive = m.group(1).lower()
            rest = m.group(2)
            s = f"{drive}:/{rest}"

    # Collapse redundant separators and dot segments using POSIX semantics (we forced "/").
    # Preserve UNC double-slash prefix.
    if s.startswith("//"):
        prefix = "//"
        rest = s[2:]
        rest = posixpath.normpath(rest)
        s = prefix + rest.lstrip("/")
    else:
        s = posixpath.normpath(s)

    # Normalize Windows drive letter casing (c:/..., not C:/...).
    if _WIN_DRIVE_RE.match(s):
        s = s[0].lower() + s[1:]

    # Drop trailing slash (but keep "/" and "c:/").
    if len(s) > 1 and s.endswith("/"):
        s = s.rstrip("/")
        if _WIN_DRIVE_RE.match(s) and not s.endswith("/"):
            # Ensure drive root keeps trailing slash form "c:/".
            if len(s) == 2:
                s = s + "/"

    # On Windows-like paths, compare case-insensitively to avoid drive letter/case issues.
    if _looks_like_windows_path(s):
        s = s.casefold()

    return s


def _work_dir_match_keys(work_dir: Path) -> set[str]:
    keys: set[str] = set()
    candidates: list[str] = []
    for raw in (os.environ.get("PWD"), str(work_dir)):
        if raw:
            candidates.append(raw)
    try:
        candidates.append(str(work_dir.resolve()))
    except Exception:
        pass
    for candidate in candidates:
        normalized = _normalize_path_for_match(candidate)
        if normalized:
            keys.add(normalized)
    return keys


def _extract_session_work_dir_norm(session_data: dict) -> str:
    """Extract a normalized work dir marker from a session file payload."""
    if not isinstance(session_data, dict):
        return ""
    raw_norm = session_data.get("work_dir_norm")
    if isinstance(raw_norm, str) and raw_norm.strip():
        return _normalize_path_for_match(raw_norm)
    raw = session_data.get("work_dir")
    if isinstance(raw, str) and raw.strip():
        return _normalize_path_for_match(raw)
    return ""


def _get_git_info() -> str:
    try:
        result = subprocess.run(
            ["git", "-C", str(script_dir), "log", "-1", "--format=%h %ci"],
            capture_output=True, text=True, encoding='utf-8', errors='replace', timeout=2
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except Exception:
        pass
    return ""


def _build_keep_open_cmd(provider: str, start_cmd: str) -> str:
    if get_shell_type() == "powershell":
        return (
            f'{start_cmd}; '
            f'$code = $LASTEXITCODE; '
            f'Write-Host "`n[{provider}] exited with code $code. Press Enter to close..."; '
            f'Read-Host; '
            f'exit $code'
        )
    return (
        f'{start_cmd}; '
        f'code=$?; '
        f'echo; echo "[{provider}] exited with code $code. Press Enter to close..."; '
        f'read -r _; '
        f'exit $code'
    )


def _build_pane_title_cmd(marker: str) -> str:
    if get_shell_type() == "powershell":
        safe = marker.replace("'", "''")
        return f"$Host.UI.RawUI.WindowTitle = '{safe}'; "
    return f"printf '\\033]0;{marker}\\007'; "

def _build_export_path_cmd(bin_dir: Path) -> str:
    """
    Ensure CCB's `bin/` is available inside the started pane/session.

    This allows running `oask`/`gask` from within Codex/Gemini/OpenCode environments consistently
    across WezTerm/tmux (and PowerShell shells on Windows).
    """
    bin_s = str(bin_dir)
    if get_shell_type() == "powershell":
        safe = bin_s.replace("'", "''")
        return f"$env:Path = '{safe};' + $env:Path; "
    return f"export PATH={shlex.quote(bin_s)}{os.pathsep}$PATH; "


class AILauncher:
    def __init__(
        self,
        providers: list,
        resume: bool = False,
        auto: bool = False,
    ):
        self.providers = providers or ["codex"]
        self.resume = resume
        self.auto = auto
        self.script_dir = Path(__file__).resolve().parent
        self.session_id = f"ai-{int(time.time())}-{os.getpid()}"
        self.temp_base = Path(tempfile.gettempdir())
        self.runtime_dir = self.temp_base / f"claude-ai-{getpass.getuser()}" / self.session_id
        self.runtime_dir.mkdir(parents=True, exist_ok=True)
        self._cleaned = False
        self.terminal_type = self._detect_terminal_type()
        self.tmux_sessions = {}
        self.tmux_panes = {}
        self.wezterm_panes = {}
        self.iterm2_panes = {}
        self.processes = {}

    def _maybe_start_caskd(self) -> None:
        def _bool_from_env(name: str):
            raw = os.environ.get(name)
            if raw is None or raw == "":
                return None
            v = raw.strip().lower()
            if v in {"0", "false", "no", "off"}:
                return False
            if v in {"1", "true", "yes", "on"}:
                return True
            return None

        # Prefer the new name; keep CCB_AUTO_CASKD for backwards compatibility.
        autostart = _bool_from_env("CCB_CASKD_AUTOSTART")
        if autostart is None:
            autostart = _bool_from_env("CCB_AUTO_CASKD")
        if autostart is False:
            return
        if _bool_from_env("CCB_CASKD") is False:
            return
        if "codex" not in self.providers:
            return
        if self.terminal_type not in ("wezterm", "iterm2"):
            return
        try:
            from caskd_daemon import ping_daemon, read_state
        except Exception as exc:
            print(f"âš ï¸ Failed to import caskd modules: {exc}")
            return

        state_file = None
        raw_state_file = (os.environ.get("CCB_CASKD_STATE_FILE") or "").strip()
        if raw_state_file:
            try:
                state_file = Path(raw_state_file).expanduser()
            except Exception:
                state_file = None

        if ping_daemon(state_file=state_file):
            st = read_state(state_file=state_file) or {}
            host = st.get("host")
            port = st.get("port")
            if host and port:
                print(f"âœ… caskd already running at {host}:{port}")
            else:
                print("âœ… caskd already running")
            return

        caskd_script = self.script_dir / "bin" / "caskd"
        if not caskd_script.exists():
            print("âš ï¸ caskd not found (bin/caskd). Reinstall or update your checkout.")
            return

        kwargs = {
            "stdin": subprocess.DEVNULL,
            "stdout": subprocess.DEVNULL,
            "stderr": subprocess.DEVNULL,
            "close_fds": True,
        }
        if os.name == "nt":
            # ä½¿ç”¨ CREATE_NO_WINDOW è€Œé DETACHED_PROCESS
            # CREATE_NO_WINDOW: éšè—çª—å£ä½†ä¿ç•™æ§åˆ¶å°é™„ç€ï¼Œå­è¿›ç¨‹å¯ç»§æ‰¿
            # DETACHED_PROCESS: å®Œå…¨è„±ç¦»æ§åˆ¶å°ï¼Œå­è¿›ç¨‹å¿…é¡»åˆ›å»ºæ–°çª—å£
            kwargs["creationflags"] = getattr(subprocess, "CREATE_NEW_PROCESS_GROUP", 0) | getattr(subprocess, "CREATE_NO_WINDOW", 0x08000000)
        else:
            kwargs["start_new_session"] = True

        try:
            subprocess.Popen([sys.executable, str(caskd_script)], **kwargs)
        except Exception as exc:
            print(f"âš ï¸ Failed to start caskd: {exc}")
            return

        deadline = time.time() + 2.0
        while time.time() < deadline:
            if ping_daemon(timeout_s=0.2, state_file=state_file):
                st = read_state(state_file=state_file) or {}
                host = st.get("host")
                port = st.get("port")
                if host and port:
                    print(f"âœ… caskd started at {host}:{port}")
                else:
                    print("âœ… caskd started")
                return
            time.sleep(0.1)
        print("âš ï¸ caskd start requested, but daemon not reachable yet")

    def _detect_terminal_type(self):
        # Forced by environment variable
        forced = (os.environ.get("CCB_TERMINAL") or os.environ.get("CODEX_TERMINAL") or "").strip().lower()
        if forced in {"wezterm", "tmux"}:
            return forced

        # When inside WezTerm pane, use wezterm
        if os.environ.get("WEZTERM_PANE"):
            return "wezterm"
        # When inside tmux, use tmux
        if os.environ.get("TMUX") or os.environ.get("TMUX_PANE"):
            return "tmux"
        # Only use iTerm2 split when in iTerm2 environment
        if os.environ.get("ITERM_SESSION_ID"):
            return "iterm2"

        # Not inside any terminal multiplexer - prefer tmux for auto-session creation
        # This allows `ccb up` in a plain terminal to create and attach to a tmux session
        if shutil.which("tmux"):
            return "tmux"

        # Fallback to WezTerm if available (will create split in new WezTerm window)
        detected = detect_terminal()
        if detected:
            return detected

        # Nothing found
        return None

    def _detect_launch_terminal(self):
        """Select terminal program for launching new windows (tmux mode only)"""
        # WezTerm mode doesn't need external terminal program
        if self.terminal_type == "wezterm":
            return None
        # tmux mode: select terminal
        terminals = ["gnome-terminal", "konsole", "alacritty", "xterm"]
        for term in terminals:
            if shutil.which(term):
                return term
        return "tmux"

    def _set_tmux_ui_active(self, active: bool) -> None:
        """
        Enable/disable CCB tmux UI theming for the *current tmux session*.

        This is session-scoped and reversible (saves/restores user options) via helper scripts
        installed to `~/.local/bin/`.
        """
        if self.terminal_type != "tmux":
            return
        if not os.environ.get("TMUX"):
            return
        script = Path.home() / ".local" / "bin" / ("ccb-tmux-on.sh" if active else "ccb-tmux-off.sh")
        if not script.exists():
            return
        try:
            subprocess.run([str(script)], check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception:
            return

    def _launch_script_in_macos_terminal(self, script_file: Path) -> bool:
        """macOS: Use Terminal.app to open new window for script (avoid tmux launcher nesting issues)"""
        if platform.system() != "Darwin":
            return False
        if not shutil.which("osascript"):
            return False
        env = os.environ.copy()
        env["CCB_WRAPPER_SCRIPT"] = str(script_file)
        subprocess.Popen(
            [
                "osascript",
                "-e",
                'tell application "Terminal" to do script "/bin/bash " & quoted form of (system attribute "CCB_WRAPPER_SCRIPT")',
                "-e",
                'tell application "Terminal" to activate',
            ],
            env=env,
        )
        return True

    def _launch_in_new_tmux_session(self) -> bool:
        """Create a new tmux session and attach to it, re-running ccb inside."""
        # IMPORTANT: session name must be unique per run. Using only a short prefix of
        # `ai-<epoch>-<pid>` collides frequently (same day) and can incorrectly attach to an old session.
        session_name = f"ccb-{self.session_id}"
        providers_str = ",".join(self.providers)
        ccb_cmd = (
            f"cd {shlex.quote(str(Path.cwd()))} && "
            f"{shlex.quote(str(self.script_dir / 'ccb'))} up {shlex.quote(providers_str)}"
        )

        # Check if session already exists
        check = subprocess.run(
            ["tmux", "has-session", "-t", session_name],
            capture_output=True,
        )
        if check.returncode == 0:
            # Session exists, ask user what to do
            print(f"âš ï¸  tmux session '{session_name}' already exists.")
            print(f"   Attaching to existing session...")
            os.execlp("tmux", "tmux", "attach-session", "-t", session_name)
            return True

        print(f"ğŸ“º {t('creating_tmux_session', session=session_name)}")

        # Create new tmux session with ccb command
        try:
            subprocess.run(
                ["tmux", "new-session", "-d", "-s", session_name, "-c", str(Path.cwd())],
                check=True,
            )
            # Send the ccb command to the new session
            subprocess.run(
                ["tmux", "send-keys", "-t", session_name, ccb_cmd, "Enter"],
                check=True,
            )
            # Attach to the session (replaces current process)
            print(f"ğŸ”— {t('attaching_to_tmux', session=session_name)}")
            os.execlp("tmux", "tmux", "attach-session", "-t", session_name)
        except subprocess.CalledProcessError as e:
            print(f"âŒ Failed to create tmux session: {e}", file=sys.stderr)
            return False
        except Exception as e:
            print(f"âŒ Failed to attach to tmux session: {e}", file=sys.stderr)
            return False
        return True  # Never reached due to execlp

    def _start_provider(self, provider: str) -> bool:
        # Handle case when no terminal detected
        if self.terminal_type is None:
            print(f"âŒ {t('no_terminal_backend')}")
            print(f"   {t('solutions')}")
            print(f"   - {t('install_wezterm')}")
            print(f"   - {t('or_install_tmux')}")
            if (shutil.which("tmux") or shutil.which("tmux.exe")) and not (os.environ.get("TMUX") or os.environ.get("TMUX_PANE")):
                print(f"   - {t('tmux_installed_not_inside')}")
            print(f"   - {t('or_set_ccb_terminal')}")
            return False

        # WezTerm mode: no tmux dependency
        if self.terminal_type == "wezterm":
            print(f"ğŸš€ {t('starting_backend', provider=provider.capitalize(), terminal='wezterm')}")
            return self._start_provider_wezterm(provider)
        elif self.terminal_type == "iterm2":
            return self._start_provider_iterm2(provider)

        # tmux mode: check if tmux is available
        if not shutil.which("tmux"):
            # Try fallback to WezTerm
            if detect_terminal() == "wezterm":
                self.terminal_type = "wezterm"
                print(f"ğŸš€ {t('starting_backend', provider=provider.capitalize(), terminal='wezterm - tmux unavailable')}")
                return self._start_provider_wezterm(provider)
            else:
                print(f"âŒ {t('tmux_not_installed')}")
                print(f"   {t('install_wezterm_or_tmux')}")
                return False

        # If not inside tmux, create a new session and attach to it
        if not os.environ.get("TMUX"):
            return self._launch_in_new_tmux_session()

        print(f"ğŸš€ {t('starting_backend', provider=provider.capitalize(), terminal='tmux')}")

        if provider == "codex":
            return self._start_codex_tmux()
        elif provider == "gemini":
            return self._start_gemini_tmux()
        elif provider == "opencode":
            return self._start_opencode_tmux()
        else:
            print(f"âŒ {t('unknown_provider', provider=provider)}")
            return False

    def _start_provider_wezterm(self, provider: str) -> bool:
        runtime = self.runtime_dir / provider
        runtime.mkdir(parents=True, exist_ok=True)

        start_cmd = self._get_start_cmd(provider)
        keep_open = os.environ.get("CODEX_WEZTERM_KEEP_OPEN", "1").lower() not in {"0", "false", "no", "off"}
        if keep_open:
            start_cmd = _build_keep_open_cmd(provider, start_cmd)
        want_grid = {"codex", "gemini", "opencode"}.issubset(set(self.providers))
        current_pane = os.environ.get("WEZTERM_PANE")
        if want_grid and current_pane:
            # 2x2 grid with current pane as top-left:
            # codex -> top-right, gemini -> bottom-left, opencode -> bottom-right.
            if not self.wezterm_panes:
                direction = "right"
                parent_pane = current_pane
            elif provider == "gemini":
                direction = "bottom"
                parent_pane = current_pane
            else:
                direction = "bottom"
                parent_pane = self.wezterm_panes.get("codex") or next(iter(self.wezterm_panes.values()))
        else:
            # Legacy layout: right column stack (top/bottom).
            direction = "right" if not self.wezterm_panes else "bottom"
            parent_pane = None
            if direction == "bottom":
                try:
                    parent_pane = next(iter(self.wezterm_panes.values()))
                except StopIteration:
                    parent_pane = None

        pane_title_marker = f"CCB-{provider.capitalize()}"
        title_cmd = _build_pane_title_cmd(pane_title_marker)
        full_cmd = title_cmd + _build_export_path_cmd(self.script_dir / "bin") + start_cmd
        backend = WeztermBackend()
        pane_id = backend.create_pane(full_cmd, str(Path.cwd()), direction=direction, percent=50, parent_pane=parent_pane)
        self.wezterm_panes[provider] = pane_id

        if provider == "codex":
            input_fifo = runtime / "input.fifo"
            output_fifo = runtime / "output.fifo"
            # WezTerm mode injects text via pane, no strong FIFO dependency; Windows/WSL may not support mkfifo
            self._write_codex_session(
                runtime,
                None,
                input_fifo,
                output_fifo,
                pane_id=pane_id,
                pane_title_marker=pane_title_marker,
                codex_start_cmd=start_cmd,
            )
            self._write_cend_registry(os.environ.get("WEZTERM_PANE", ""), pane_id)
        elif provider == "gemini":
            self._write_gemini_session(runtime, None, pane_id=pane_id, pane_title_marker=pane_title_marker, start_cmd=start_cmd)
        else:
            self._write_opencode_session(runtime, None, pane_id=pane_id, pane_title_marker=pane_title_marker, start_cmd=start_cmd)

        print(f"âœ… {t('started_backend', provider=provider.capitalize(), terminal='wezterm pane', pane_id=pane_id)}")
        return True

    def _start_provider_iterm2(self, provider: str) -> bool:
        runtime = self.runtime_dir / provider
        runtime.mkdir(parents=True, exist_ok=True)

        start_cmd = self._get_start_cmd(provider)
        # In iTerm2 split, process exit will close pane; keep pane open by default to view exit info
        keep_open = os.environ.get("CODEX_ITERM2_KEEP_OPEN", "1").lower() not in {"0", "false", "no", "off"}
        if keep_open:
            start_cmd = (
                f"{start_cmd}; "
                f"code=$?; "
                f'echo; echo \"[{provider}] exited with code $code. Press Enter to close...\"; '
                f"read -r _; "
                f"exit $code"
            )
        want_grid = {"codex", "gemini", "opencode"}.issubset(set(self.providers))
        current_pane = os.environ.get("ITERM_SESSION_ID")
        if want_grid and current_pane:
            if not self.iterm2_panes:
                direction = "right"
                parent_pane = current_pane
            elif provider == "gemini":
                direction = "bottom"
                parent_pane = current_pane
            else:
                direction = "bottom"
                parent_pane = self.iterm2_panes.get("codex") or next(iter(self.iterm2_panes.values()))
        else:
            direction = "right" if not self.iterm2_panes else "bottom"
            parent_pane = None
            if direction == "bottom":
                try:
                    parent_pane = next(iter(self.iterm2_panes.values()))
                except StopIteration:
                    parent_pane = None

        backend = Iterm2Backend()
        pane_id = backend.create_pane(
            _build_export_path_cmd(self.script_dir / "bin") + start_cmd,
            str(Path.cwd()),
            direction=direction,
            percent=50,
            parent_pane=parent_pane,
        )
        self.iterm2_panes[provider] = pane_id

        if provider == "codex":
            input_fifo = runtime / "input.fifo"
            output_fifo = runtime / "output.fifo"
            # iTerm2 mode injects text via pane, no strong FIFO dependency
            self._write_codex_session(runtime, None, input_fifo, output_fifo, pane_id=pane_id, codex_start_cmd=start_cmd)
        elif provider == "gemini":
            self._write_gemini_session(runtime, None, pane_id=pane_id, start_cmd=start_cmd)
        else:
            self._write_opencode_session(runtime, None, pane_id=pane_id, start_cmd=start_cmd)

        print(f"âœ… {t('started_backend', provider=provider.capitalize(), terminal='iterm2 session', pane_id=pane_id)}")
        return True

    def _work_dir_strings(self, work_dir: Path) -> list[str]:
        candidates: list[str] = []
        env_pwd = os.environ.get("PWD")
        if env_pwd:
            candidates.append(env_pwd)
        candidates.append(str(work_dir))
        try:
            candidates.append(str(work_dir.resolve()))
        except Exception:
            pass
        # de-dup while preserving order
        seen: set[str] = set()
        result: list[str] = []
        for candidate in candidates:
            if candidate not in seen:
                seen.add(candidate)
                result.append(candidate)
        return result

    def _read_json_file(self, path: Path) -> dict:
        try:
            if not path.exists():
                return {}
            # Session files are written as UTF-8; on Windows PowerShell 5.1 the default encoding
            # may not be UTF-8, so always decode explicitly and tolerate UTF-8 BOM.
            raw = path.read_text(encoding="utf-8-sig")
            data = json.loads(raw)
            return data if isinstance(data, dict) else {}
        except Exception:
            return {}

    def _write_json_file(self, path: Path, data: dict) -> None:
        try:
            path.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
        except Exception:
            pass

    def _clear_codex_log_binding(self, data: dict) -> dict:
        try:
            if not isinstance(data, dict):
                return {}
            cleared = dict(data)
            for key in ("codex_session_path", "codex_session_id", "codex_start_cmd"):
                if key in cleared:
                    cleared.pop(key, None)
            if cleared.get("active") is False:
                cleared["active"] = True
            return cleared
        except Exception as exc:
            print(f"âš ï¸ codex_session_clear_failed: {exc}", file=sys.stderr)
            return data if isinstance(data, dict) else {}

    def _claude_session_file(self) -> Path:
        return Path.cwd() / ".claude-session"

    def _read_local_claude_session_id(self) -> str | None:
        data = self._read_json_file(self._claude_session_file())
        sid = data.get("claude_session_id") or data.get("session_id")
        if isinstance(sid, str) and sid.strip():
            # Guard against path-format mismatch (Windows case/slash differences, MSYS paths, etc.).
            recorded_norm = _extract_session_work_dir_norm(data)
            if not recorded_norm:
                # Old/foreign session file without a recorded work dir: refuse to resume to avoid cross-project reuse.
                return None
            current_keys = _work_dir_match_keys(Path.cwd())
            if current_keys and recorded_norm not in current_keys:
                return None
            return sid.strip()
        return None

    def _write_local_claude_session(self, session_id: str, active: bool = True) -> None:
        path = self._claude_session_file()
        data = self._read_json_file(path)
        work_dir = Path.cwd()
        data.update(
            {
                "claude_session_id": session_id,
                "work_dir": str(work_dir),
                "work_dir_norm": _normalize_path_for_match(str(work_dir)),
                "active": bool(active),
                "started_at": data.get("started_at") or time.strftime("%Y-%m-%d %H:%M:%S"),
                "updated_at": time.strftime("%Y-%m-%d %H:%M:%S"),
            }
        )
        self._write_json_file(path, data)

    def _get_latest_codex_session_id(self) -> tuple[str | None, bool]:
        """
        Returns (session_id, has_any_history_for_cwd).
        Session id is Codex CLI's UUID used by `codex resume <id>`.
        Always scans session logs to find the latest session for current cwd,
        then updates local .codex-session file.
        """
        project_session = Path.cwd() / ".codex-session"

        # Always scan Codex session logs for the latest session bound to this cwd.
        # This ensures we get the latest session even if user did /clear during run.
        root = Path(os.environ.get("CODEX_SESSION_ROOT") or (Path.home() / ".codex" / "sessions")).expanduser()
        if not root.exists():
            return None, False
        work_keys = _work_dir_match_keys(Path.cwd())
        if not work_keys:
            return None, False
        try:
            logs = sorted(
                (p for p in root.glob("**/*.jsonl") if p.is_file()),
                key=lambda p: p.stat().st_mtime,
                reverse=True,
            )
        except Exception:
            logs = []
        for log_path in logs[:400]:
            try:
                with log_path.open("r", encoding="utf-8", errors="ignore") as handle:
                    first = handle.readline().strip()
            except OSError:
                continue
            if not first:
                continue
            try:
                entry = json.loads(first)
            except Exception:
                continue
            if not isinstance(entry, dict) or entry.get("type") != "session_meta":
                continue
            payload = entry.get("payload") if isinstance(entry.get("payload"), dict) else {}
            cwd = payload.get("cwd")
            if not isinstance(cwd, str) or not cwd.strip():
                continue
            if _normalize_path_for_match(cwd) not in work_keys:
                continue
            sid = payload.get("id")
            if isinstance(sid, str) and sid:
                # Update local .codex-session file with latest session id
                data = self._read_json_file(project_session) if project_session.exists() else {}
                work_dir = Path.cwd()
                data.update({
                    "codex_session_id": sid,
                    "codex_session_path": str(log_path),
                    "work_dir": str(work_dir),
                    "work_dir_norm": _normalize_path_for_match(str(work_dir)),
                    "updated_at": time.strftime("%Y-%m-%d %H:%M:%S"),
                })
                self._write_json_file(project_session, data)
                return sid, True
        return None, False

    def _build_codex_start_cmd(self) -> str:
        cmd = "codex -c=disable_paste_burst=true --dangerously-bypass-approvals-and-sandbox" if self.auto else "codex -c=disable_paste_burst=true"
        codex_resumed = False
        if self.resume:
            session_id, has_history = self._get_latest_codex_session_id()
            if session_id:
                cmd = f"{cmd} resume {session_id}"
                print(f"ğŸ” {t('resuming_session', provider='Codex', session_id=session_id[:8])}")
                codex_resumed = True

            if not codex_resumed:
                print(f"â„¹ï¸ {t('no_history_fresh', provider='Codex')}")
        return cmd

    def _get_latest_gemini_project_hash(self) -> tuple[str | None, bool]:
        """
        Returns (project_hash, has_any_history_for_cwd).
        Gemini CLI stores sessions under ~/.gemini/tmp/<sha256(cwd)>/chats/.
        """
        import hashlib

        gemini_root = Path(os.environ.get("GEMINI_ROOT") or (Path.home() / ".gemini" / "tmp")).expanduser()

        candidates: list[str] = []
        try:
            candidates.append(str(Path.cwd().absolute()))
        except Exception:
            pass
        try:
            candidates.append(str(Path.cwd().resolve()))
        except Exception:
            pass
        env_pwd = (os.environ.get("PWD") or "").strip()
        if env_pwd:
            try:
                candidates.append(os.path.abspath(os.path.expanduser(env_pwd)))
            except Exception:
                candidates.append(env_pwd)

        seen: set[str] = set()
        for candidate in candidates:
            if not candidate or candidate in seen:
                continue
            seen.add(candidate)
            project_hash = hashlib.sha256(candidate.encode()).hexdigest()
            chats_dir = gemini_root / project_hash / "chats"
            if not chats_dir.exists():
                continue
            session_files = list(chats_dir.glob("session-*.json"))
            if session_files:
                return project_hash, True

        return None, False

    def _build_gemini_start_cmd(self) -> str:
        cmd = "gemini --yolo" if self.auto else "gemini"
        if self.resume:
            _, has_history = self._get_latest_gemini_project_hash()
            if has_history:
                cmd = f"{cmd} --resume latest"
                print(f"ğŸ” {t('resuming_session', provider='Gemini', session_id='')}")
            else:
                print(f"â„¹ï¸ {t('no_history_fresh', provider='Gemini')}")
        return cmd

    def _warmup_provider(self, provider: str, timeout: float = 8.0) -> bool:
        if provider == "codex":
            ping_script = self.script_dir / "bin" / "cping"
        elif provider == "gemini":
            ping_script = self.script_dir / "bin" / "gping"
        elif provider == "opencode":
            ping_script = self.script_dir / "bin" / "oping"
        else:
            return False

        if not ping_script.exists():
            return False

        print(f"ğŸ”§ Warmup: {ping_script.name}")
        deadline = time.time() + timeout
        last_result: subprocess.CompletedProcess[str] | None = None
        sleep_s = 0.3
        while time.time() < deadline:
            last_result = subprocess.run(
                [sys.executable, str(ping_script)],
                cwd=str(Path.cwd()),
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='replace',
            )
            if last_result.returncode == 0:
                out = (last_result.stdout or "").strip()
                if out:
                    print(out)
                return True
            time.sleep(sleep_s)
            sleep_s = min(1.0, sleep_s * 1.5)

        if last_result:
            out = ((last_result.stdout or "") + "\n" + (last_result.stderr or "")).strip()
            if out:
                print(out)
        print(f"âš ï¸ Warmup failed: {provider}")
        return False

    def _get_start_cmd(self, provider: str) -> str:
        if provider == "codex":
            # NOTE: Codex TUI has paste-burst detection; terminal injection (wezterm send-text/tmux paste-buffer)
            # is often detected as "paste", causing Enter to only line-break not submit. Disable detection by default.
            return self._build_codex_start_cmd()
        elif provider == "gemini":
            return self._build_gemini_start_cmd()
        elif provider == "opencode":
            return self._build_opencode_start_cmd()
        return ""

    def _build_opencode_start_cmd(self) -> str:
        # OpenCode CLI (TUI). Allow override via env for custom wrappers.
        cmd = (os.environ.get("OPENCODE_START_CMD") or "opencode").strip() or "opencode"

        # Auto mode: relax permissions and enable web tools via config file.
        if self.auto:
            self._ensure_opencode_auto_config()

        # Resume mode: continue last session
        if self.resume:
            cmd = f"{cmd} --continue"

        return cmd

    def _ensure_opencode_auto_config(self) -> None:
        """
        Ensure project-local opencode.json exists with full allow permissions (auto mode).
        Best-effort: never raise (should not block startup).
        """
        try:
            config_path = Path.cwd() / "opencode.json"

            desired = {
                "permission": {
                    "edit": "allow",
                    "bash": "allow",
                    "skill": "allow",
                    "webfetch": "allow",
                    "doom_loop": "allow",
                    "external_directory": "allow",
                }
            }

            current: dict = {}
            if config_path.exists():
                try:
                    current_raw = config_path.read_text(encoding="utf-8")
                    current_obj = json.loads(current_raw)
                    if isinstance(current_obj, dict):
                        current = current_obj
                except Exception:
                    current = {}

            current["permission"] = dict(desired["permission"])

            tmp_path = config_path.with_suffix(".tmp")
            tmp_path.write_text(json.dumps(current, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
            os.replace(tmp_path, config_path)
        except Exception as exc:
            # Non-fatal; OpenCode can still run with interactive permissions.
            print(f"âš ï¸ Failed to update OpenCode config: {exc}", file=sys.stderr)

    def _start_codex_tmux(self) -> bool:
        runtime = self.runtime_dir / "codex"
        runtime.mkdir(parents=True, exist_ok=True)

        input_fifo = runtime / "input.fifo"
        output_fifo = runtime / "output.fifo"

        if not input_fifo.exists():
            os.mkfifo(input_fifo, 0o600)
        if not output_fifo.exists():
            os.mkfifo(output_fifo, 0o644)

        start_cmd = _build_export_path_cmd(self.script_dir / "bin") + self._build_codex_start_cmd()
        pane_title_marker = "CCB-Codex"

        backend = TmuxBackend()

        want_grid = {"codex", "gemini", "opencode"}.issubset(set(self.providers))
        current_pane = os.environ.get("TMUX_PANE")
        if want_grid and current_pane:
            if not self.tmux_panes:
                direction = "right"
                parent_pane = current_pane
            else:
                direction = "bottom"
                parent_pane = self.tmux_panes.get("codex") or next(iter(self.tmux_panes.values()))
        else:
            direction = "right" if not self.tmux_panes else "bottom"
            parent_pane = None
            if direction == "bottom":
                try:
                    parent_pane = next(iter(self.tmux_panes.values()))
                except StopIteration:
                    parent_pane = None

        pane_id = backend.create_pane("", str(Path.cwd()), direction=direction, percent=50, parent_pane=parent_pane)
        backend.respawn_pane(pane_id, cmd=start_cmd, cwd=str(Path.cwd()), remain_on_exit=True)
        backend.set_pane_title(pane_id, pane_title_marker)
        backend.set_pane_user_option(pane_id, "@ccb_agent", "Codex")

        self.tmux_panes["codex"] = pane_id

        self._write_cend_registry(os.environ.get("TMUX_PANE", ""), pane_id)

        bridge_script = self.script_dir / "lib" / "codex_dual_bridge.py"
        bridge_env = os.environ.copy()
        bridge_env["CODEX_TERMINAL"] = "tmux"
        bridge_env["CODEX_TMUX_SESSION"] = pane_id
        bridge_env["CODEX_SESSION_ID"] = self.session_id
        bridge_env["CODEX_RUNTIME_DIR"] = str(runtime)
        bridge_env["CODEX_INPUT_FIFO"] = str(input_fifo)
        bridge_env["CODEX_OUTPUT_FIFO"] = str(output_fifo)
        bridge_env["CODEX_TMUX_LOG"] = str(runtime / "bridge_output.log")
        bridge_env["PYTHONPATH"] = str(self.script_dir) + os.pathsep + bridge_env.get("PYTHONPATH", "")

        try:
            cp = subprocess.run(
                ["tmux", "display-message", "-p", "-t", pane_id, "#{pane_pid}"],
                capture_output=True,
                text=True,
                encoding="utf-8",
                errors="replace",
                check=True,
            )
            pane_pid = (cp.stdout or "").strip()
            if pane_pid.isdigit():
                (runtime / "codex.pid").write_text(pane_pid + "\n")
        except Exception:
            pass

        bridge_proc = subprocess.Popen(
            [sys.executable, str(bridge_script), "--runtime-dir", str(runtime), "--session-id", self.session_id],
            env=bridge_env,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            start_new_session=True,
        )
        try:
            (runtime / "bridge.pid").write_text(str(bridge_proc.pid), encoding="utf-8")
        except Exception:
            pass

        self._write_codex_session(
            runtime,
            None,
            input_fifo,
            output_fifo,
            pane_id=pane_id,
            pane_title_marker=pane_title_marker,
            codex_start_cmd=start_cmd,
        )

        print(f"âœ… {t('started_backend', provider='Codex', terminal='tmux pane', pane_id=pane_id)}")
        return True

    def _start_gemini_tmux(self) -> bool:
        runtime = self.runtime_dir / "gemini"
        runtime.mkdir(parents=True, exist_ok=True)

        start_cmd = _build_export_path_cmd(self.script_dir / "bin") + self._build_gemini_start_cmd()
        pane_title_marker = "CCB-Gemini"

        backend = TmuxBackend()

        want_grid = {"codex", "gemini", "opencode"}.issubset(set(self.providers))
        current_pane = os.environ.get("TMUX_PANE")
        if want_grid and current_pane:
            if not self.tmux_panes:
                direction = "right"
                parent_pane = current_pane
            elif "codex" in self.tmux_panes and "opencode" not in self.tmux_panes:
                direction = "bottom"
                parent_pane = current_pane
            else:
                direction = "bottom"
                parent_pane = self.tmux_panes.get("codex") or next(iter(self.tmux_panes.values()))
        else:
            direction = "right" if not self.tmux_panes else "bottom"
            parent_pane = None
            if direction == "bottom":
                try:
                    parent_pane = next(iter(self.tmux_panes.values()))
                except StopIteration:
                    parent_pane = None

        pane_id = backend.create_pane("", str(Path.cwd()), direction=direction, percent=50, parent_pane=parent_pane)
        backend.respawn_pane(pane_id, cmd=start_cmd, cwd=str(Path.cwd()), remain_on_exit=True)
        backend.set_pane_title(pane_id, pane_title_marker)
        backend.set_pane_user_option(pane_id, "@ccb_agent", "Gemini")

        self.tmux_panes["gemini"] = pane_id

        self._write_gemini_session(
            runtime,
            None,
            pane_id=pane_id,
            pane_title_marker=pane_title_marker,
            start_cmd=start_cmd,
        )

        print(f"âœ… {t('started_backend', provider='Gemini', terminal='tmux pane', pane_id=pane_id)}")
        return True

    def _start_opencode_tmux(self) -> bool:
        runtime = self.runtime_dir / "opencode"
        runtime.mkdir(parents=True, exist_ok=True)

        start_cmd = _build_export_path_cmd(self.script_dir / "bin") + self._build_opencode_start_cmd()
        pane_title_marker = "CCB-OpenCode"

        backend = TmuxBackend()

        want_grid = {"codex", "gemini", "opencode"}.issubset(set(self.providers))
        current_pane = os.environ.get("TMUX_PANE")
        if want_grid and current_pane:
            if not self.tmux_panes:
                direction = "right"
                parent_pane = current_pane
            elif "codex" in self.tmux_panes and "gemini" not in self.tmux_panes:
                direction = "bottom"
                parent_pane = current_pane
            else:
                direction = "bottom"
                parent_pane = self.tmux_panes.get("codex") or next(iter(self.tmux_panes.values()))
        else:
            direction = "right" if not self.tmux_panes else "bottom"
            parent_pane = None
            if direction == "bottom":
                try:
                    parent_pane = next(iter(self.tmux_panes.values()))
                except StopIteration:
                    parent_pane = None

        pane_id = backend.create_pane("", str(Path.cwd()), direction=direction, percent=50, parent_pane=parent_pane)
        backend.respawn_pane(pane_id, cmd=start_cmd, cwd=str(Path.cwd()), remain_on_exit=True)
        backend.set_pane_title(pane_id, pane_title_marker)
        backend.set_pane_user_option(pane_id, "@ccb_agent", "OpenCode")

        self.tmux_panes["opencode"] = pane_id

        self._write_opencode_session(
            runtime,
            None,
            pane_id=pane_id,
            pane_title_marker=pane_title_marker,
            start_cmd=start_cmd,
        )

        print(f"âœ… {t('started_backend', provider='OpenCode', terminal='tmux pane', pane_id=pane_id)}")
        return True

    def _write_codex_session(self, runtime, tmux_session, input_fifo, output_fifo, pane_id=None, pane_title_marker=None, codex_start_cmd=None):
        session_file = Path.cwd() / ".codex-session"

        # Pre-check permissions
        writable, reason, fix = check_session_writable(session_file)
        if not writable:
            print(f"âŒ Cannot write {session_file.name}: {reason}", file=sys.stderr)
            print(f"ğŸ’¡ Fix: {fix}", file=sys.stderr)
            return False

        data = {}
        if session_file.exists():
            data = self._read_json_file(session_file)

        if not self.resume:
            data = self._clear_codex_log_binding(data)

        work_dir = Path.cwd()
        data.update({
            "session_id": self.session_id,
            "runtime_dir": str(runtime),
            "input_fifo": str(input_fifo),
            "output_fifo": str(output_fifo),
            "terminal": self.terminal_type,
            "tmux_session": tmux_session,
            "pane_id": pane_id,
            "pane_title_marker": pane_title_marker,
            "tmux_log": str(runtime / "bridge_output.log"),
            "work_dir": str(work_dir),
            "work_dir_norm": _normalize_path_for_match(str(work_dir)),
            "active": True,
            "started_at": time.strftime("%Y-%m-%d %H:%M:%S"),
        })
        if codex_start_cmd:
            data["codex_start_cmd"] = str(codex_start_cmd)
            data["start_cmd"] = str(codex_start_cmd)

        ok, err = safe_write_session(session_file, json.dumps(data, ensure_ascii=False, indent=2))
        if not ok:
            print(err, file=sys.stderr)
            return False
        return True

    def _write_cend_registry(self, claude_pane_id: str, codex_pane_id: str | None) -> bool:
        if not claude_pane_id:
            return False
        record = {
            "ccb_session_id": self.session_id,
            "claude_pane_id": claude_pane_id,
            "codex_pane_id": codex_pane_id,
            "work_dir": str(Path.cwd()),
            "terminal": self.terminal_type,
        }
        ok = upsert_registry(record)
        if not ok:
            print("âš ï¸ Failed to update cpend registry", file=sys.stderr)
        return ok

    def _write_gemini_session(self, runtime, tmux_session, pane_id=None, pane_title_marker=None, start_cmd=None):
        session_file = Path.cwd() / ".gemini-session"

        # Pre-check permissions
        writable, reason, fix = check_session_writable(session_file)
        if not writable:
            print(f"âŒ Cannot write {session_file.name}: {reason}", file=sys.stderr)
            print(f"ğŸ’¡ Fix: {fix}", file=sys.stderr)
            return False

        data = {
            "session_id": self.session_id,
            "runtime_dir": str(runtime),
            "terminal": self.terminal_type,
            "tmux_session": tmux_session,
            "pane_id": pane_id,
            "pane_title_marker": pane_title_marker,
            "work_dir": str(Path.cwd()),
            "active": True,
            "started_at": time.strftime("%Y-%m-%d %H:%M:%S"),
            "start_cmd": str(start_cmd) if start_cmd else None,
        }

        ok, err = safe_write_session(session_file, json.dumps(data, ensure_ascii=False, indent=2))
        if not ok:
            print(err, file=sys.stderr)
            return False
        return True

    def _write_opencode_session(self, runtime, tmux_session, pane_id=None, pane_title_marker=None, start_cmd=None):
        session_file = Path.cwd() / ".opencode-session"

        writable, reason, fix = check_session_writable(session_file)
        if not writable:
            print(f"âŒ Cannot write {session_file.name}: {reason}", file=sys.stderr)
            print(f"ğŸ’¡ Fix: {fix}", file=sys.stderr)
            return False

        data = {
            "session_id": self.session_id,
            "ccb_session_id": self.session_id,
            "runtime_dir": str(runtime),
            "terminal": self.terminal_type,
            "tmux_session": tmux_session,
            "pane_id": pane_id,
            "pane_title_marker": pane_title_marker,
            "work_dir": str(Path.cwd()),
            "active": True,
            "started_at": time.strftime("%Y-%m-%d %H:%M:%S"),
            "start_cmd": str(start_cmd) if start_cmd else None,
        }

        ok, err = safe_write_session(session_file, json.dumps(data, ensure_ascii=False, indent=2))
        if not ok:
            print(err, file=sys.stderr)
            return False
        return True

    def _claude_project_dir(self, work_dir: Path) -> Path:
        projects_root = Path.home() / ".claude" / "projects"
        # Claude Code uses a filesystem-friendly key derived from the working directory.
        # To handle symlinked paths (PWD) vs physical paths (resolve()), try multiple candidates.
        candidates: list[Path] = []
        env_pwd = os.environ.get("PWD")
        if env_pwd:
            try:
                candidates.append(Path(env_pwd))
            except Exception:
                pass
        candidates.extend([work_dir])
        try:
            candidates.append(work_dir.resolve())
        except Exception:
            pass

        for candidate in candidates:
            key = re.sub(r"[^A-Za-z0-9]", "-", str(candidate))
            project_dir = projects_root / key
            if project_dir.exists():
                return project_dir

        # Fallback to a best-effort key even if the directory doesn't exist yet.
        try:
            fallback_path = work_dir.resolve()
        except Exception:
            fallback_path = work_dir
        key = re.sub(r"[^A-Za-z0-9]", "-", str(fallback_path))
        return projects_root / key

    def _get_latest_claude_session_id(self) -> tuple[str | None, bool]:
        """
        Returns (session_id, has_any_history).
        - session_id: latest UUID-like session id if found (for `claude --resume <id>`).
        - has_any_history: whether this project has any Claude sessions on disk.
        """
        project_dir = self._claude_project_dir(Path.cwd())
        if not project_dir.exists():
            return None, False

        session_files = list(project_dir.glob("*.jsonl"))
        if not session_files:
            return None, False

        session_env_root = Path.home() / ".claude" / "session-env"

        uuid_sessions: list[Path] = []
        for session_file in session_files:
            try:
                uuid.UUID(session_file.stem)
                # Ignore zero-byte placeholders and sessions Claude cannot actually resume.
                if session_file.stat().st_size <= 0:
                    continue
                if not (session_env_root / session_file.stem).exists():
                    continue
                uuid_sessions.append(session_file)
            except Exception:
                continue

        if not uuid_sessions:
            return None, True

        latest = max(uuid_sessions, key=lambda p: p.stat().st_mtime)
        return latest.stem, True

    def _find_claude_cmd(self) -> str:
        """Find Claude CLI executable"""
        if sys.platform == "win32":
            for cmd in ["claude.exe", "claude.cmd", "claude.bat", "claude"]:
                path = shutil.which(cmd)
                if path:
                    return path
            npm_paths = [
                Path(os.environ.get("APPDATA", "")) / "npm" / "claude.cmd",
                Path(os.environ.get("ProgramFiles", "")) / "nodejs" / "claude.cmd",
            ]
            for npm_path in npm_paths:
                if npm_path.exists():
                    return str(npm_path)
        else:
            path = shutil.which("claude")
            if path:
                return path
        raise FileNotFoundError(
            "âŒ Claude CLI not found. Install: npm install -g @anthropic-ai/claude-code"
        )

    def _start_claude(self) -> int:
        print(f"ğŸš€ {t('starting_claude')}")

        env = os.environ.copy()
        if "codex" in self.providers:
            runtime = self.runtime_dir / "codex"
            env["CODEX_SESSION_ID"] = self.session_id
            env["CODEX_RUNTIME_DIR"] = str(runtime)
            env["CODEX_INPUT_FIFO"] = str(runtime / "input.fifo")
            env["CODEX_OUTPUT_FIFO"] = str(runtime / "output.fifo")
            env["CODEX_TERMINAL"] = self.terminal_type
            if self.terminal_type == "wezterm":
                env["CODEX_WEZTERM_PANE"] = self.wezterm_panes.get("codex", "")
            elif self.terminal_type == "iterm2":
                env["CODEX_ITERM2_PANE"] = self.iterm2_panes.get("codex", "")
            else:
                env["CODEX_TMUX_SESSION"] = self.tmux_panes.get("codex", "")

        if "gemini" in self.providers:
            runtime = self.runtime_dir / "gemini"
            env["GEMINI_SESSION_ID"] = self.session_id
            env["GEMINI_RUNTIME_DIR"] = str(runtime)
            env["GEMINI_TERMINAL"] = self.terminal_type
            if self.terminal_type == "wezterm":
                env["GEMINI_WEZTERM_PANE"] = self.wezterm_panes.get("gemini", "")
            elif self.terminal_type == "iterm2":
                env["GEMINI_ITERM2_PANE"] = self.iterm2_panes.get("gemini", "")
            else:
                env["GEMINI_TMUX_SESSION"] = self.tmux_panes.get("gemini", "")

        if "opencode" in self.providers:
            runtime = self.runtime_dir / "opencode"
            env["OPENCODE_SESSION_ID"] = self.session_id
            env["OPENCODE_RUNTIME_DIR"] = str(runtime)
            env["OPENCODE_TERMINAL"] = self.terminal_type
            if self.terminal_type == "wezterm":
                env["OPENCODE_WEZTERM_PANE"] = self.wezterm_panes.get("opencode", "")
            elif self.terminal_type == "iterm2":
                env["OPENCODE_ITERM2_PANE"] = self.iterm2_panes.get("opencode", "")
            else:
                env["OPENCODE_TMUX_SESSION"] = self.tmux_panes.get("opencode", "")

        try:
            claude_cmd = self._find_claude_cmd()
        except FileNotFoundError as e:
            print(str(e))
            return 1

        cmd = [claude_cmd]

        # Check for .autoflow folder in current directory (CCA project)
        autoflow_dir = Path.cwd() / ".autoflow"
        if autoflow_dir.is_dir():
            # CCA project detected: use plan mode regardless of -a flag
            cmd.extend(["--permission-mode", "plan"])
        elif self.auto:
            # Auto mode without CCA: bypass all permissions
            cmd.append("--dangerously-skip-permissions")
        else:
            # If CCA (Claude Code Autoflow) is installed, start Claude in plan mode
            cca_path, _ = _detect_cca()
            if cca_path:
                cmd.extend(["--permission-mode", "plan"])
        if self.resume:
            _, has_history = self._get_latest_claude_session_id()
            if has_history:
                cmd.append("--continue")
                print(f"ğŸ” {t('resuming_claude', session_id='')}")
            else:
                print(f"â„¹ï¸ {t('no_claude_session')}")

        print(f"ğŸ“‹ Session ID: {self.session_id}")
        print(f"ğŸ“ Runtime dir: {self.runtime_dir}")
        print(f"ğŸ”Œ Active backends: {', '.join(self.providers)}")
        print()
        print("ğŸ¯ Available commands:")
        if "codex" in self.providers:
            print("   cask/cping/cpend - Codex communication")
        if "gemini" in self.providers:
            print("   gask/gping/gpend - Gemini communication")
        if "opencode" in self.providers:
            print("   oask/oping/opend - OpenCode communication")
        print()
        print(f"Executing: {' '.join(cmd)}")

        try:
            # Let subprocess inherit stdio by default. Explicitly passing sys.stdin/out/err
            # can produce non-console handles on Windows (especially after re-wrapping
            # stdout/stderr for UTF-8), which may trigger issues in Node-based CLIs.
            return subprocess.run(cmd, env=env).returncode
        except KeyboardInterrupt:
            print(f"\nâš ï¸ {t('user_interrupted')}")
            return 130

    def cleanup(self):
        if self._cleaned:
            return
        self._cleaned = True
        print(f"\nğŸ§¹ {t('cleaning_up')}")

        # Revert tmux UI theming early so the user's session returns to normal even if cleanup fails later.
        try:
            self._set_tmux_ui_active(False)
        except Exception:
            pass

        if self.terminal_type == "wezterm":
            backend = WeztermBackend()
            for provider, pane_id in self.wezterm_panes.items():
                if pane_id:
                    backend.kill_pane(pane_id)
        elif self.terminal_type == "iterm2":
            backend = Iterm2Backend()
            for provider, pane_id in self.iterm2_panes.items():
                if pane_id:
                    backend.kill_pane(pane_id)
        else:
            backend = TmuxBackend()
            for provider, pane_id in self.tmux_panes.items():
                if pane_id:
                    backend.kill_pane(pane_id)

        for session_file in [Path.cwd() / ".codex-session", Path.cwd() / ".gemini-session", Path.cwd() / ".opencode-session", Path.cwd() / ".claude-session"]:
            if session_file.exists():
                try:
                    data = self._read_json_file(session_file)
                    if not data:
                        continue
                    data["active"] = False
                    data["ended_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
                    safe_write_session(session_file, json.dumps(data, ensure_ascii=False, indent=2))
                except Exception:
                    pass

        import shutil
        if self.runtime_dir.exists():
            shutil.rmtree(self.runtime_dir, ignore_errors=True)

        print(f"âœ… {t('cleanup_complete')}")

    def run_up(self) -> int:
        git_info = _get_git_info()
        version_str = f"v{VERSION}" + (f" ({git_info})" if git_info else "")
        print(f"ğŸš€ Claude Code Bridge {version_str}")
        print(f"ğŸ“… {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"ğŸ”Œ Backends: {', '.join(self.providers)}")
        print("=" * 50)

        atexit.register(self.cleanup)
        signal.signal(signal.SIGINT, lambda s, f: (self.cleanup(), sys.exit(0)))
        signal.signal(signal.SIGTERM, lambda s, f: (self.cleanup(), sys.exit(0)))

        # tmux-only: enable CCB UI theming for the current session while CCB is running.
        try:
            self._set_tmux_ui_active(True)
        except Exception:
            pass

        # tmux-only: label the current pane as Claude so pane titles are consistent.
        # (Codex/Gemini/OpenCode panes are titled when created.)
        try:
            if self.terminal_type == "tmux" and os.environ.get("TMUX_PANE"):
                backend = TmuxBackend()
                backend.set_pane_title(os.environ["TMUX_PANE"], "Claude")
                backend.set_pane_user_option(os.environ["TMUX_PANE"], "@ccb_agent", "Claude")
        except Exception:
            pass

        providers = list(self.providers)
        if self.terminal_type in ("wezterm", "iterm2") or (self.terminal_type == "tmux" and os.environ.get("TMUX_PANE")):
            # Stable layout: codex on top, gemini on bottom (when both are present).
            order = {"codex": 0, "gemini": 1, "opencode": 2}
            providers.sort(key=lambda p: order.get(p, 99))

        for provider in providers:
            if not self._start_provider(provider):
                return 1
            self._warmup_provider(provider)

        # Optional: start caskd after Codex session file exists (first startup convenience).
        self._maybe_start_caskd()

        try:
            return self._start_claude()
        finally:
            self.cleanup()


def cmd_up(args):
    providers = _parse_providers(args.providers or ["codex"])
    if not providers:
        return 2
    launcher = AILauncher(
        providers=providers,
        resume=args.resume,
        auto=args.auto,
    )
    return launcher.run_up()


def cmd_kill(args):
    providers = _parse_providers(args.providers or ["codex", "gemini", "opencode"], allow_unknown=True)
    if not providers:
        return 2

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            print(f"âš ï¸ {provider}: Session file not found")
            continue

        try:
            data = json.loads(session_file.read_text(encoding="utf-8-sig"))
            terminal = data.get("terminal", "tmux")
            pane_id = data.get("pane_id") if terminal in ("wezterm", "iterm2") else (data.get("pane_id") or data.get("tmux_session") or "")

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                backend.kill_pane(pane_id)
            elif terminal == "iterm2" and pane_id:
                backend = Iterm2Backend()
                backend.kill_pane(pane_id)
            elif pane_id and shutil.which("tmux"):
                backend = TmuxBackend()
                if str(pane_id).startswith("%"):
                    backend.kill_pane(str(pane_id))
                else:
                    tmux_session = str(data.get("tmux_session") or "").strip()
                    if tmux_session and not tmux_session.startswith("%"):
                        subprocess.run(["tmux", "kill-session", "-t", tmux_session], stderr=subprocess.DEVNULL)
                        subprocess.run(["tmux", "kill-session", "-t", f"launcher-{tmux_session}"], stderr=subprocess.DEVNULL)
                    else:
                        backend.kill_pane(str(pane_id))

            data["active"] = False
            data["ended_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
            safe_write_session(session_file, json.dumps(data, ensure_ascii=False, indent=2))

            print(f"âœ… {provider.capitalize()} terminated")
        except Exception as e:
            print(f"âŒ {provider}: {e}")

    return 0


def _parse_providers(values: list[str], *, allow_unknown: bool = False) -> list[str]:
    """
    Parse providers from argv.

    Accept both:
      - space-separated: `ccb up codex gemini opencode`
      - comma-separated: `ccb up codex,gemini,opencode`

    Returns a de-duplicated list preserving order.
    """
    allowed = {"codex", "gemini", "opencode"}
    raw_parts: list[str] = []
    for item in (values or []):
        if item is None:
            continue
        for part in str(item).split(","):
            p = part.strip().lower()
            if p:
                raw_parts.append(p)

    if not raw_parts:
        return []

    seen: set[str] = set()
    parsed: list[str] = []
    unknown: list[str] = []
    for p in raw_parts:
        if p in seen:
            continue
        seen.add(p)
        if p in allowed or allow_unknown:
            parsed.append(p)
        else:
            unknown.append(p)

    if unknown and not allow_unknown:
        print(f"âŒ invalid provider(s): {', '.join(unknown)}", file=sys.stderr)
        print("ğŸ’¡ use: ccb up codex gemini opencode  (spaces)  or  ccb up codex,gemini,opencode  (commas)", file=sys.stderr)
        print("ğŸ’¡ allowed: codex, gemini, opencode", file=sys.stderr)
        return []

    return parsed


def _get_version_info(dir_path: Path) -> dict:
    """Get commit hash, date and version from install directory"""
    info = {"commit": None, "date": None, "version": None}
    ccb_file = dir_path / "ccb"
    if ccb_file.exists():
        try:
            content = ccb_file.read_text(encoding='utf-8', errors='replace')
            for line in content.split('\n')[:60]:
                line = line.strip()
                if line.startswith('VERSION') and '=' in line:
                    info["version"] = line.split('=')[1].strip().strip('"').strip("'")
                elif line.startswith('GIT_COMMIT') and '=' in line:
                    val = line.split('=')[1].strip().strip('"').strip("'")
                    if val:
                        info["commit"] = val
                elif line.startswith('GIT_DATE') and '=' in line:
                    val = line.split('=')[1].strip().strip('"').strip("'")
                    if val:
                        info["date"] = val
        except Exception:
            pass
    if shutil.which("git") and (dir_path / ".git").exists():
        result = subprocess.run(
            ["git", "-C", str(dir_path), "log", "-1", "--format=%h|%ci"],
            capture_output=True, text=True, encoding='utf-8', errors='replace'
        )
        if result.returncode == 0 and result.stdout.strip():
            parts = result.stdout.strip().split("|")
            if len(parts) >= 2:
                info["commit"] = parts[0]
                info["date"] = parts[1].split()[0]
    return info


def _format_version_info(info: dict) -> str:
    """Format version info for display"""
    parts = []
    if info.get("version"):
        parts.append(f"v{info['version']}")
    if info.get("commit"):
        parts.append(info["commit"])
    if info.get("date"):
        parts.append(info["date"])
    return " ".join(parts) if parts else "unknown"


def _get_remote_version_info() -> dict | None:
    """Get latest version info from GitHub API"""
    import urllib.request
    import ssl

    api_url = "https://api.github.com/repos/bfly123/claude_code_bridge/commits/main"
    try:
        ctx = ssl.create_default_context()
        req = urllib.request.Request(api_url, headers={"User-Agent": "ccb"})
        with urllib.request.urlopen(req, context=ctx, timeout=5) as resp:
            data = json.loads(resp.read().decode('utf-8'))
            commit = data.get("sha", "")[:7]
            date_str = data.get("commit", {}).get("committer", {}).get("date", "")
            date = date_str[:10] if date_str else None
            return {"commit": commit, "date": date}
    except Exception:
        pass

    if shutil.which("curl"):
        result = subprocess.run(
            ["curl", "-fsSL", api_url],
            capture_output=True, text=True, encoding='utf-8', errors='replace', timeout=10
        )
        if result.returncode == 0:
            try:
                data = json.loads(result.stdout)
                commit = data.get("sha", "")[:7]
                date_str = data.get("commit", {}).get("committer", {}).get("date", "")
                date = date_str[:10] if date_str else None
                return {"commit": commit, "date": date}
            except Exception:
                pass
    return None


def _detect_cca() -> tuple[str | None, str | None]:
    """Detect CCA installation. Returns (cca_path, install_dir)"""
    cca_path = shutil.which("cca")
    if cca_path:
        install_dir = Path(cca_path).resolve().parent
        return cca_path, str(install_dir)
    candidates = [
        Path.home() / ".local/share/claude_code_autoflow",
        Path.home() / ".local/bin/cca",
    ]
    # Windows ç‰¹å®šè·¯å¾„
    if platform.system() == "Windows":
        localappdata = os.environ.get("LOCALAPPDATA", "")
        if localappdata:
            candidates.extend([
                Path(localappdata) / "cca",
                Path(localappdata) / "claude_code_autoflow",
                Path(localappdata) / "cca" / "bin" / "cca.cmd",
                Path(localappdata) / "cca" / "cca.ps1",
            ])
        # å›é€€è·¯å¾„
        candidates.extend([
            Path.home() / "AppData/Local/cca",
            Path.home() / "AppData/Local/claude_code_autoflow",
        ])
    for p in candidates:
        if p.exists():
            return str(p), str(p.parent if p.is_file() else p)
    return None, None


def _get_cca_version(cca_path: str) -> str | None:
    """Get CCA version by running cca -v"""
    try:
        result = subprocess.run(
            [cca_path, "-v"], capture_output=True, text=True,
            encoding="utf-8", errors="replace", timeout=5
        )
        if result.returncode == 0:
            return result.stdout.strip().split('\n')[0]
    except Exception:
        pass
    return None


def cmd_version(args):
    """Show version info and check for updates"""
    script_root = Path(__file__).resolve().parent
    # å€™é€‰ç›®å½•åˆ—è¡¨ï¼ˆä¼˜å…ˆçº§é€’å‡ï¼‰
    candidates = [
        script_root,  # å½“å‰è„šæœ¬ç›®å½•
        Path(os.environ.get("CODEX_INSTALL_PREFIX", "")).expanduser() if os.environ.get("CODEX_INSTALL_PREFIX") else None,
        Path.home() / ".local/share/codex-dual",  # Linux/macOS
    ]

    # Windows ç‰¹å®šè·¯å¾„
    if platform.system() == "Windows":
        localappdata = os.environ.get("LOCALAPPDATA", "")
        if localappdata:
            candidates.extend([
                Path(localappdata) / "codex-dual",
                Path(localappdata) / "claude-code-bridge",
            ])
        candidates.append(Path.home() / "AppData/Local/codex-dual")

    # é€‰æ‹©ç¬¬ä¸€ä¸ªåŒ…å« ccb æ–‡ä»¶çš„ç›®å½•
    install_dir = None
    for candidate in candidates:
        if candidate and (candidate / "ccb").exists():
            install_dir = candidate
            break
    if not install_dir:
        install_dir = script_root

    local_info = _get_version_info(install_dir)
    local_str = _format_version_info(local_info)

    print(f"ccb (Claude Code Bridge) {local_str}")
    print(f"Install path: {install_dir}")

    print("\nChecking for updates...")
    remote_info = _get_remote_version_info()

    if remote_info is None:
        print("âš ï¸  Unable to check for updates (network error)")
    elif local_info.get("commit") and remote_info.get("commit"):
        if local_info["commit"] == remote_info["commit"]:
            print(f"âœ… Up to date")
        else:
            remote_str = f"{remote_info['commit']} {remote_info.get('date', '')}"
            print(f"ğŸ“¦ Update available: {remote_str}")
            print(f"   Run: ccb update")
    else:
        print("âš ï¸  Unable to compare versions")

    # CCA info
    print()
    cca_path, cca_dir = _detect_cca()
    if cca_path:
        cca_ver = _get_cca_version(cca_path)
        print(f"cca (Claude Code Autoflow) {cca_ver or 'unknown'}")
        print(f"Install path: {cca_dir}")
    else:
        print("cca (Claude Code Autoflow) not installed")
        print("  Install: ccb update cca")
        print("  Tip: CCA significantly enhances workflow automation")

    return 0


def _update_cca(silent: bool = False) -> int:
    """Install or update CCA"""
    import urllib.request
    import tarfile
    import tempfile

    cca_repo = "https://github.com/bfly123/claude_code_autoflow"
    cca_path, cca_dir = _detect_cca()

    # Try git pull if .git exists
    if cca_dir and Path(cca_dir).exists() and (Path(cca_dir) / ".git").exists():
        if not silent:
            print("ğŸ”„ Updating CCA via git pull...")
        result = subprocess.run(
            ["git", "-C", cca_dir, "pull", "--ff-only"],
            capture_output=True, text=True, encoding="utf-8", errors="replace"
        )
        if result.returncode == 0:
            print("âœ… CCA updated successfully")
            return 0

    # Fresh install via tarball
    if not silent:
        print("ğŸ“¦ Installing CCA from GitHub...")
    # æ ¹æ®æ“ä½œç³»ç»Ÿé€‰æ‹©å®‰è£…ç›®å½•
    if platform.system() == "Windows":
        # Windows: ä½¿ç”¨ %LOCALAPPDATA%\cca
        localappdata = os.environ.get("LOCALAPPDATA", "")
        if localappdata:
            install_dir = Path(localappdata) / "cca"
        else:
            install_dir = Path.home() / "AppData/Local/cca"
    else:
        # Unix/Linux/macOS: ä½¿ç”¨ ~/.local/share/claude_code_autoflow
        install_dir = Path.home() / ".local/share/claude_code_autoflow"
    tarball_url = f"{cca_repo}/archive/refs/heads/main.tar.gz"

    try:
        with tempfile.TemporaryDirectory() as tmpdir:
            tarball = Path(tmpdir) / "cca.tar.gz"
            urllib.request.urlretrieve(tarball_url, tarball)
            with tarfile.open(tarball, "r:gz") as tf:
                tf.extractall(tmpdir)
            extracted = Path(tmpdir) / "claude_code_autoflow-main"
            if install_dir.exists():
                shutil.rmtree(install_dir)
            shutil.copytree(extracted, install_dir)
            # æ ¹æ®æ“ä½œç³»ç»Ÿé€‰æ‹©å®‰è£…è„šæœ¬
            if platform.system() == "Windows":
                # Windows: ä¼˜å…ˆä½¿ç”¨ install.ps1
                install_script = install_dir / "install.ps1"
                if install_script.exists():
                    result = subprocess.run(
                        ["powershell", "-NoProfile", "-ExecutionPolicy", "Bypass",
                         "-File", str(install_script), "install"],
                        cwd=str(install_dir),
                        check=False
                    )
                    if result.returncode != 0:
                        print("âš ï¸  PowerShell installation had issues, but CCA files are copied")
                else:
                    # å›é€€ï¼šç›´æ¥ä½¿ç”¨ cca.ps1
                    cca_script = install_dir / "cca.ps1"
                    if cca_script.exists():
                        print("âš ï¸  install.ps1 not found, but cca.ps1 is available")
                        print(f"   You can run: powershell -File \"{cca_script}\" <command>")
                    else:
                        print("âš ï¸  Neither install.ps1 nor cca.ps1 found")
                        print(f"   Files extracted to: {install_dir}")
            else:
                # Unix/Linux/macOS: ä½¿ç”¨ install.sh
                install_script = install_dir / "install.sh"
                if install_script.exists():
                    subprocess.run(["bash", str(install_script), "install"], cwd=str(install_dir))
                else:
                    print("âš ï¸  install.sh not found")
        print("âœ… CCA installed successfully")
        print(f"   Path: {install_dir}")
        return 0
    except Exception as e:
        print(f"âŒ CCA install failed: {e}")
        return 1


def cmd_update(args):
    """Update ccb to latest version"""
    # Handle "ccb update cca" subcommand
    if hasattr(args, 'target') and args.target == 'cca':
        return _update_cca()

    import urllib.request
    import tarfile
    import tempfile

    # Prefer the directory where this script resides (installed copy), then fall back to env/default.
    script_root = Path(__file__).resolve().parent
    default_install_dir = Path.home() / ".local/share/codex-dual"
    install_dir = Path(os.environ.get("CODEX_INSTALL_PREFIX") or default_install_dir).expanduser()
    if (script_root / "install.sh").exists():
        install_dir = script_root
    repo_url = "https://github.com/bfly123/claude_code_bridge"

    # Get current version info before update
    old_info = _get_version_info(install_dir)

    print("ğŸ”„ Checking for updates...")

    # Method 1: Prefer git if available
    if shutil.which("git") and (install_dir / ".git").exists():
        print("ğŸ“¦ Updating via git pull...")
        result = subprocess.run(
            ["git", "-C", str(install_dir), "pull", "--ff-only"],
            capture_output=True, text=True, encoding='utf-8', errors='replace'
        )
        if result.returncode == 0:
            print(result.stdout.strip() if result.stdout.strip() else "Already up to date.")
            print("ğŸ”§ Reinstalling...")
            subprocess.run([str(install_dir / "install.sh"), "install"])
            # Show upgrade info
            new_info = _get_version_info(install_dir)
            old_str = _format_version_info(old_info)
            new_str = _format_version_info(new_info)
            if old_info.get("commit") != new_info.get("commit"):
                print(f"âœ… Updated: {old_str} â†’ {new_str}")
            else:
                print(f"âœ… Already up to date: {new_str}")
            # CCA update/suggest
            cca_path, _ = _detect_cca()
            if cca_path:
                print("\nğŸ”„ Updating CCA...")
                _update_cca(silent=False)
            else:
                print("\nğŸ’¡ CCA (Claude Code Autoflow) not installed")
                print("   Install: ccb update cca")
                print("   Tip: Significantly enhances workflow automation")
            return 0
        else:
            print(f"âš ï¸ Git pull failed: {result.stderr.strip()}")
            print("Falling back to tarball download...")

    def _pick_temp_base_dir() -> Path:
        candidates: list[Path] = []
        for key in ("CCB_TMPDIR", "TMPDIR", "TEMP", "TMP"):
            value = (os.environ.get(key) or "").strip()
            if value:
                candidates.append(Path(value).expanduser())
        try:
            candidates.append(Path(tempfile.gettempdir()))
        except Exception:
            pass
        candidates.extend(
            [
                Path("/tmp"),
                Path("/var/tmp"),
                Path("/usr/tmp"),
                Path.home() / ".cache" / "ccb" / "tmp",
                install_dir / ".tmp",
                Path.cwd() / ".tmp",
            ]
        )

        for base in candidates:
            try:
                base.mkdir(parents=True, exist_ok=True)
                probe = base / f".ccb_tmp_probe_{os.getpid()}_{int(time.time() * 1000)}"
                probe.write_bytes(b"1")
                probe.unlink(missing_ok=True)
                return base
            except Exception:
                continue

        raise RuntimeError(
            "âŒ No usable temporary directory found.\n"
            "Fix options:\n"
            "  - Create /tmp (Linux/WSL): sudo mkdir -p /tmp && sudo chmod 1777 /tmp\n"
            "  - Or set TMPDIR/CCB_TMPDIR to a writable path (e.g. export TMPDIR=$HOME/.cache/tmp)"
        )

    # Method 2: Download tarball
    tarball_url = f"{repo_url}/archive/refs/heads/main.tar.gz"
    try:
        tmp_base = _pick_temp_base_dir()
    except Exception as exc:
        print(str(exc))
        return 1
    tmp_dir = tmp_base / "ccb_update"

    try:
        print(f"ğŸ“¥ Downloading latest version...")
        if tmp_dir.exists():
            shutil.rmtree(tmp_dir)
        tmp_dir.mkdir(parents=True, exist_ok=True)
        tarball_path = tmp_dir / "main.tar.gz"

        # Prefer curl/wget (better certificate handling)
        downloaded = False
        if shutil.which("curl"):
            result = subprocess.run(
                ["curl", "-fsSL", "-o", str(tarball_path), tarball_url],
                capture_output=True
            )
            downloaded = result.returncode == 0
        if not downloaded and shutil.which("wget"):
            result = subprocess.run(
                ["wget", "-q", "-O", str(tarball_path), tarball_url],
                capture_output=True
            )
            downloaded = result.returncode == 0
        if not downloaded:
            # Fallback to urllib (may have SSL issues)
            import ssl
            try:
                urllib.request.urlretrieve(tarball_url, tarball_path)
            except ssl.SSLError:
                print("âš ï¸ SSL certificate verification failed, trying to skip...")
                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE
                with urllib.request.urlopen(tarball_url, context=ctx) as resp:
                    tarball_path.write_bytes(resp.read())

        print("ğŸ“‚ Extracting...")
        def _safe_extract(tar: tarfile.TarFile, dest: Path) -> None:
            dest = dest.resolve()
            for member in tar.getmembers():
                member_path = (dest / member.name).resolve()
                if not str(member_path).startswith(str(dest) + os.sep):
                    raise RuntimeError(f"Unsafe tar member path: {member.name}")
            # Python 3.14+ requires filter argument
            try:
                tar.extractall(dest, filter='data')
            except TypeError:
                tar.extractall(dest)

        with tarfile.open(tarball_path, "r:gz") as tar:
            _safe_extract(tar, tmp_dir)

        extracted_dir = tmp_dir / "claude_code_bridge-main"

        print("ğŸ”§ Installing...")
        env = os.environ.copy()
        env["CODEX_INSTALL_PREFIX"] = str(install_dir)
        # Windows: use install.ps1, Unix: use install.sh
        if platform.system() == "Windows":
            ps1_script = extracted_dir / "install.ps1"
            subprocess.run(
                ["powershell", "-ExecutionPolicy", "Bypass", "-File", str(ps1_script), "install"],
                check=True, env=env
            )
        else:
            subprocess.run([str(extracted_dir / "install.sh"), "install"], check=True, env=env)

        # Show upgrade info
        new_info = _get_version_info(install_dir)
        old_str = _format_version_info(old_info)
        new_str = _format_version_info(new_info)
        if old_info.get("commit") != new_info.get("commit") or old_info.get("version") != new_info.get("version"):
            print(f"âœ… Updated: {old_str} â†’ {new_str}")
        else:
            print(f"âœ… Already up to date: {new_str}")
        # CCA update/suggest
        cca_path, _ = _detect_cca()
        if cca_path:
            print("\nğŸ”„ Updating CCA...")
            _update_cca(silent=False)
        else:
            print("\nğŸ’¡ CCA (Claude Code Autoflow) not installed")
            print("   Install: ccb update cca")
            print("   Tip: Significantly enhances workflow automation")
        return 0

    except Exception as e:
        print(f"âŒ Update failed: {e}")
        return 1

    finally:
        if tmp_dir.exists():
            shutil.rmtree(tmp_dir, ignore_errors=True)


def main():
    parser = argparse.ArgumentParser(description="Claude AI unified launcher", add_help=True)
    subparsers = parser.add_subparsers(dest="command", help="Subcommands")

    # up subcommand
    up_parser = subparsers.add_parser("up", help="Start AI backends")
    up_parser.add_argument(
        "providers",
        nargs="*",
        help="Backends to start (space or comma separated): codex, gemini, opencode",
    )
    up_parser.add_argument("-r", "--resume", "--restore", action="store_true", help="Resume context")
    up_parser.add_argument("-a", "--auto", action="store_true", help="Full auto permission mode")

    # kill subcommand
    kill_parser = subparsers.add_parser("kill", help="Terminate session")
    kill_parser.add_argument("providers", nargs="*", default=[], help="Backends to terminate (codex/gemini/opencode)")

    # update subcommand
    update_parser = subparsers.add_parser("update", help="Update to latest version")
    update_parser.add_argument("target", nargs="?", choices=["cca"],
                               help="Optional: 'cca' to install/update CCA only")

    # version subcommand
    subparsers.add_parser("version", help="Show version and check for updates")

    argv = sys.argv[1:]
    # Backward/shortcut compatibility
    if argv and argv[0] in {"-r", "--resume", "--restore"}:
        argv = ["up"] + argv
    elif argv and argv[0] in {"-v", "--version"}:
        argv = ["version"]
    args = parser.parse_args(argv)

    if not args.command:
        parser.print_help()
        return 0

    if args.command == "up":
        return cmd_up(args)
    elif args.command == "kill":
        return cmd_kill(args)
    elif args.command == "update":
        return cmd_update(args)
    elif args.command == "version":
        return cmd_version(args)
    else:
        parser.print_help()
        return 1


if __name__ == "__main__":
    sys.exit(main())
