#!/usr/bin/env python3
"""
gask - Send message to Gemini and wait for reply (sync).

Designed to be used with Claude Code's run_in_background=true.
If --output is provided,  reply is written atomically to that file and stdout stays empty.
"""

from __future__ import annotations

import os
import sys
from pathlib import Path

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))
from compat import setup_windows_encoding

setup_windows_encoding()

from cli_output import EXIT_ERROR, EXIT_NO_REPLY, EXIT_OK, atomic_write_text

import time

from env_utils import env_bool
from askd_client import (
    state_file_from_env,
    find_project_session_file,
    try_daemon_request,
    maybe_start_daemon,
    wait_for_daemon_ready,
    check_background_mode,
)
from providers import GASK_CLIENT_SPEC

def _wait_for_done_reply(log_reader, state: dict, timeout: float, req_id: str, quiet: bool):
    deadline = time.time() + timeout
    latest = ""

    from gaskd_protocol import extract_reply_for_req, is_done_text

    while True:
        remaining = deadline - time.time()
        if remaining <= 0:
            break
        reply, state = log_reader.wait_for_message(state, min(remaining, 1.0))
        if reply is None:
            continue
        latest = str(reply)
        if is_done_text(latest, req_id):
            return extract_reply_for_req(latest, req_id), EXIT_OK

    if latest and not quiet:
        print("[WARN] Done marker not detected, returning partial reply", file=sys.stderr)
    return extract_reply_for_req(latest, req_id), EXIT_NO_REPLY


def _usage() -> None:
    print("Usage: gask [--timeout SECONDS] [--output FILE] <message>", file=sys.stderr)


def main(argv: list[str]) -> int:
    if len(argv) <= 1 and sys.stdin.isatty():
        print("Usage: gask [--timeout SECONDS] [--output FILE] <message>", file=sys.stderr)
        return EXIT_ERROR

    output_path: Path | None = None
    timeout: float | None = None
    quiet = False

    parts: list[str] = []
    it = iter(argv[1:])
    for token in it:
        if token in ("-h", "--help"):
            print("Usage: gask [--timeout SECONDS] [--output FILE] <message>", file=sys.stderr)
            return EXIT_OK
        if token in ("-q", "--quiet"):
            quiet = True
            continue
        if token in ("-o", "--output"):
            try:
                output_path = Path(next(it)).expanduser()
            except StopIteration:
                print("[ERROR] --output requires a file path", file=sys.stderr)
                return EXIT_ERROR
            continue
        if token in ("-t", "--timeout"):
            try:
                timeout = float(next(it))
            except StopIteration:
                print("[ERROR] --timeout requires a number", file=sys.stderr)
                return EXIT_ERROR
            except ValueError:
                print("[ERROR] --timeout must be a number", file=sys.stderr)
                return EXIT_ERROR
            continue
        parts.append(token)

    message = " ".join(parts).strip()
    if not message and not sys.stdin.isatty():
        message = sys.stdin.read().strip()
    if not message:
        print("[ERROR] Message cannot be empty", file=sys.stderr)
        return EXIT_ERROR

    if timeout is None:
        try:
            timeout = float(os.environ.get("CCB_SYNC_TIMEOUT", "3600.0"))
        except Exception:
            timeout = 3600.0

    try:
        # Strict mode: require run_in_background=true in Claude Code
        if os.environ.get("CLAUDECODE") == "1" and not check_background_mode():
            print("[ERROR] gask MUST be called with run_in_background=true", file=sys.stderr)
            print("Correct usage: Bash(gask \"...\", run_in_background=true)", file=sys.stderr)
            return EXIT_ERROR

        # Prefer daemon mode: daemon performs per-session serialization and should accept concurrent submissions.
        daemon_result = try_daemon_request(GASK_CLIENT_SPEC, Path.cwd(), message, timeout, quiet, state_file_from_env(GASK_CLIENT_SPEC.state_file_env))
        if daemon_result is None and maybe_start_daemon(GASK_CLIENT_SPEC, Path.cwd()):
            wait_for_daemon_ready(GASK_CLIENT_SPEC, timeout_s=min(2.0, max(0.2, float(timeout))))
            daemon_result = try_daemon_request(GASK_CLIENT_SPEC, Path.cwd(), message, timeout, quiet, state_file_from_env(GASK_CLIENT_SPEC.state_file_env))
        if daemon_result is not None:
            reply, exit_code = daemon_result
            if output_path:
                atomic_write_text(output_path, reply + "\n")
                return exit_code
            sys.stdout.write(reply)
            if not reply.endswith("\n"):
                sys.stdout.write("\n")
            return exit_code

        if not env_bool(GASK_CLIENT_SPEC.enabled_env, True):
            print(f"[ERROR] {GASK_CLIENT_SPEC.enabled_env}=0: gask daemon mode disabled.", file=sys.stderr)
            return EXIT_ERROR
        if not find_project_session_file(Path.cwd(), GASK_CLIENT_SPEC.session_filename):
            print("[ERROR] No active Gemini session found for this directory.", file=sys.stderr)
            print("Run `ccb up gemini` in this project first.", file=sys.stderr)
            return EXIT_ERROR
        print("[ERROR] gask daemon required but not available.", file=sys.stderr)
        print("Start it with `gaskd` (or enable autostart via CCB_GASKD_AUTOSTART=1).", file=sys.stderr)
        return EXIT_ERROR
    except KeyboardInterrupt:
        return 130
    except Exception as exc:
        print(f"[ERROR] {exc}", file=sys.stderr)
        return EXIT_ERROR


if __name__ == "__main__":
    sys.exit(main(sys.argv))
